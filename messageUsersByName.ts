const fs = require("fs");
const { IgApiClient } = require("instagram-private-api");
const config = require("./config.json");

// read users from json file generated by python
let rawData = fs.readFileSync("users.json");
let users = JSON.parse(rawData);

rawData = fs.readFileSync("messagedUsers.json");
let messagedUsers = [];
try {
    messagedUsers = JSON.parse(rawData);
} catch (error) {
    console.error("No users messaged yet. This error can be ignored")
}

let newUsers = users.filter((user) => messagedUsers.indexOf(user) == -1) // Only add Users to array if they arent alread in "messagedUsers"
newUsers = [...new Set(newUsers)]; // remove duplicates

// Array with all user (messaged & will be messaged). No Duplicates
let combinedUsers = messagedUsers.concat(newUsers);
combinedUsers = [...new Set(combinedUsers)];

// prep instagram
const ig = new IgApiClient();
ig.state.generateDevice(config.InstaUser);

(async () => {
    // Login with instagram user
    await ig.simulate.preLoginFlow();
    const loggedInUser = await ig.account.login(config.InstaUser, config.InstaPassword);
    process.nextTick(async () => await ig.simulate.postLoginFlow());

    // send messages
    message(newUsers);
    fs.writeFileSync("messagedUsers.json", JSON.stringify(combinedUsers));
})();

// Custom timer for wait during iteration
const timer = ms => new Promise(res => setTimeout(res, ms));

// Message all the users given in the "users" array
async function message(users) {    
    for(const user of users) {
        console.log(`\nTrying to message user "${user}"`);
        let userID = 0;

        // try finding userID
        try {
            userID = await ig.user.getIdByUsername(user);
            console.log(`Found user with userID ${userID}"`);
        } catch (error) {
            console.error(`"${user}" was not found. You may be blocked by this user.`)
        }       
        // Get the target's profile
        const profile = ig.entity.profile(userID.toString());

        // Check Category and Bio
        let info = await profile.client.user.info(userID)
        let isARapper = false;
        const bio = info.biography.toLowerCase();
        const category = info.category;
        const external_url =  info.external_url.toLowerCase();

        // We assume User is a rapper
        if (category == "Musician/Band" || external_url.includes("music.apple.com") || external_url.includes("open.spotify.com") || bio.includes("artist") || bio.includes("unsigned artist")) {
            isARapper = true;
        }

        // We assume User is not a rapper
        if (bio.includes("producer") || bio.includes("beatmaker") || bio.includes("making beats") || bio.includes("beats for you") || bio.includes("buy beats") || bio.includes("get beats") || bio.includes("find beats") || ((bio.includes("arts") || bio.includes("art")) && bio.includes("make")) || bio.includes("logo") || bio.includes("graphic design") || bio.includes("toon your picture") || ((bio.includes("make") || bio.includes("design")) && bio.includes("album cover")) || bio.includes("new beat") || bio.includes("cover art") || external_url.includes("beatstars")) {
            isARapper = false
        }

        // If user is not a rapper got to next user
        if(!isARapper) {
            console.log(`"${user}" is not a rapper. Skipping.`);
            continue;
        }

        // Follow the user if not already 
        let status = await profile.client.friendship.show(userID);
        if(status.following === false) {
            console.log(`Not currently following "${user}". Sending Request.`);
            await profile.client.friendship.create(userID);  
        }   

        // create message thread
        const thread = ig.entity.directThread([userID.toString()]);

        // try sending messages
        try {
            await thread.broadcastText(config.MessageUsername);
            console.log(`Successfully sent message to "${user}`);
        } catch (error) {
            console.error(`Message could not be sent to "${user}". Will still be added to messagedUsers. Please contact manually or ignore.`)
        }

        // Delay before next execution
        let delay = config.MessageDelay + (Math.random() * 3000) // increase delay up to 3s 
        await timer(delay);
    }
}